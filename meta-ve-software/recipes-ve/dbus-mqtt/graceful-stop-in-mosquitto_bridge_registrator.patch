From b0883f5f7e909498c2bdcb29771892d099b6dc39 Mon Sep 17 00:00:00 2001
From: Wiebe Cazemier <wiebe@ytec.nl>
Date: Mon, 1 Oct 2018 13:02:19 +0000
Subject: [PATCH] Graceful stop in mosquitto_bridge_registrator.py

This is needed for fixing mqtt-rpc and dbus-mqtt. It allows for a more
graceful shutdown, allowing the server response to be used and the
generated password to be saved (instead of the process just dying and
not getting a chance to save it). Otherwise the server may have
processed the POST, but the client then ignores it. This causes
subsequent MQTT password posts to fail, because it will post new random
passwords, and which don't match was already stored, obviously.

Change is backwards compatible.

https://github.com/victronenergy/venus-private/issues/72
---
 mosquitto_bridge_registrator.py | 20 ++++++++++++++------
 1 file changed, 14 insertions(+), 6 deletions(-)

diff --git a/mosquitto_bridge_registrator.py b/mosquitto_bridge_registrator.py
index c3794c0..a2c7f01 100644
--- a/mosquitto_bridge_registrator.py
+++ b/mosquitto_bridge_registrator.py
@@ -63,6 +63,7 @@ class MosquittoBridgeRegistrator(object):
 
 	def __init__(self, system_id, restart_mosquitto=True):
 		self._init_broker_timer = None
+		self._aborted = threading.Event()
 		self._client_id = None
 		self._system_id = system_id
 		self._global_broker_username = "ccgxapikey_" + self._system_id
@@ -74,17 +75,24 @@ def register(self):
 		if self._init_broker_timer is not None:
 			return
 		if self._init_broker(quiet=False, timeout=5):
-			logging.info("[InitBroker] Registration failed. Retrying in thread, silently.")
-			logging.getLogger("requests").setLevel(logging.WARNING)
-			# Not using gobject to keep these blocking operations out of the event loop
-			self._init_broker_timer = RepeatingTimer(self._init_broker, 60)
-			self._init_broker_timer.start()
+			if not self._aborted.is_set():
+				logging.info("[InitBroker] Registration failed. Retrying in thread, silently.")
+				logging.getLogger("requests").setLevel(logging.WARNING)
+				# Not using gobject to keep these blocking operations out of the event loop
+				self._init_broker_timer = RepeatingTimer(self._init_broker, 60)
+				self._init_broker_timer.start()
+
+	def abort_gracefully(self):
+		self._aborted.set()
+		if self._init_broker_timer:
+			self._init_broker_timer.stop()
+			self._init_broker_timer.join()
 
 	@property
 	def client_id(self):
 		return self._client_id
 
-	def _init_broker(self, quiet=True, timeout=30):
+	def _init_broker(self, quiet=True, timeout=5):
 		try:
 			with open(LockFilePath, "a") as lockFile:
 				fcntl.flock(lockFile, fcntl.LOCK_EX)
