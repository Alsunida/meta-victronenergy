From 24fbe121916663c7c90ec98c706135cec5dbec80 Mon Sep 17 00:00:00 2001
From: Wiebe Cazemier <wiebe@ytec.nl>
Date: Mon, 8 Oct 2018 12:23:43 +0000
Subject: [PATCH] Fix lost posted mqtt password

When we would post a password and the server accepts it but we never see
the response (because of a dropped connection for instance), subsequent
posting new random passwords failed, because one was already stored.

So, when we post a password, we're storing it now, so that we post the
same one in case it fails, and then we are sure the server accepts it.

Backwards compatible change (it still reads the password from the
Mosquitto config file, if it's present).

https://github.com/victronenergy/venus-private/issues/72
---
 mosquitto_bridge_registrator.py | 24 +++++++++++++++++++++++-
 1 file changed, 23 insertions(+), 1 deletion(-)

diff --git a/mosquitto_bridge_registrator.py b/mosquitto_bridge_registrator.py
index a2c7f01..28c9dea 100644
--- a/mosquitto_bridge_registrator.py
+++ b/mosquitto_bridge_registrator.py
@@ -12,6 +12,7 @@
 VrmBroker = 'mqtt.victronenergy.com'
 SettingsPath = os.environ.get('DBUS_MQTT_PATH') or '/data/conf/mosquitto.d'
 BridgeConfigPath = os.path.join(SettingsPath, 'vrm_bridge.conf')
+MqttPasswordFile = "/data/conf/mqtt_password.txt"
 BridgeSettings = '''# Generated by MosquittoBridgeRegistrator. Any changes will be overwritten on service start.
 connection vrm
 address {3}:443
@@ -71,6 +72,27 @@ def __init__(self, system_id, restart_mosquitto=True):
 		self._restart_mosquitto = restart_mosquitto
 		self._requests_log_level = logging.getLogger("requests").getEffectiveLevel()
 
+	def load_or_generate_mqtt_password(self):
+		"""In case posting the password to storemqttpassword.php was processed
+		by the server, but we never saw the response, we need to keep it around
+		for the next time (don't post a random new one).
+
+		This way of storing the password was incepted later, and makes it
+		backwards compatible.
+		"""
+
+		if os.path.exists(MqttPasswordFile):
+			with open(MqttPasswordFile, "r") as f:
+				logging.info("Using {}".format(MqttPasswordFile))
+				password = f.read().strip()
+				return password
+		else:
+			with open(MqttPasswordFile, "w") as f:
+				logging.info("Writing new {}".format(MqttPasswordFile))
+				password = get_random_string(32)
+				f.write(password)
+				return password
+
 	def register(self):
 		if self._init_broker_timer is not None:
 			return
@@ -115,7 +137,7 @@ def _init_broker(self, quiet=True, timeout=5):
 				if self._client_id is None:
 					self._client_id = 'ccgx_' + get_random_string(12)
 				if self._global_broker_password is None:
-					self._global_broker_password = get_random_string(32)
+					self._global_broker_password = self.load_or_generate_mqtt_password()
 				# Get to the actual registration
 				if not quiet:
 					logging.info('[InitBroker] Registering CCGX at VRM portal')
